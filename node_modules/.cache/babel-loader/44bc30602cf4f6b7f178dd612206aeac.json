{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultConfig = exports[\"default\"] = void 0;\n\nvar _reactFastCompare = _interopRequireDefault(require(\"react-fast-compare\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defaultConfig = {\n  color: '#dee4fd',\n  radius: [0.5, 3.0],\n  speed: [1.0, 3.0],\n  wind: [-0.5, 2.0],\n  changeFrequency: 200,\n  rotationSpeed: [-1.0, 1.0]\n};\nexports.defaultConfig = defaultConfig;\n/**\r\n * An individual snowflake that will update it's location every call to `update`\r\n * and draw itself to the canvas every call to `draw`.\r\n */\n\nvar Snowflake = /*#__PURE__*/function () {\n  function Snowflake(canvas) {\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Snowflake);\n\n    _defineProperty(this, \"config\", void 0);\n\n    _defineProperty(this, \"params\", void 0);\n\n    _defineProperty(this, \"framesSinceLastUpdate\", void 0);\n\n    _defineProperty(this, \"image\", void 0); // Set custom config\n\n\n    this.updateConfig(config); // Setting initial parameters\n\n    var _this$config = this.config,\n        radius = _this$config.radius,\n        wind = _this$config.wind,\n        speed = _this$config.speed,\n        rotationSpeed = _this$config.rotationSpeed;\n    this.params = {\n      x: (0, _utils.random)(0, canvas.offsetWidth),\n      y: (0, _utils.random)(-canvas.offsetHeight, 0),\n      rotation: (0, _utils.random)(0, 360),\n      radius: _utils.random.apply(void 0, _toConsumableArray(radius)),\n      speed: _utils.random.apply(void 0, _toConsumableArray(speed)),\n      wind: _utils.random.apply(void 0, _toConsumableArray(wind)),\n      rotationSpeed: _utils.random.apply(void 0, _toConsumableArray(rotationSpeed)),\n      nextSpeed: _utils.random.apply(void 0, _toConsumableArray(wind)),\n      nextWind: _utils.random.apply(void 0, _toConsumableArray(speed)),\n      nextRotationSpeed: _utils.random.apply(void 0, _toConsumableArray(rotationSpeed))\n    };\n    this.framesSinceLastUpdate = 0;\n  }\n\n  _createClass(Snowflake, [{\n    key: \"selectImage\",\n    value: function selectImage() {\n      if (this.config.images && this.config.images.length > 0) {\n        this.image = (0, _utils.randomElement)(this.config.images);\n      } else {\n        this.image = undefined;\n      }\n    }\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(config) {\n      var previousConfig = this.config;\n      this.config = _objectSpread(_objectSpread({}, defaultConfig), config);\n      this.config.changeFrequency = (0, _utils.random)(this.config.changeFrequency, this.config.changeFrequency * 1.5); // Update the radius if the config has changed, it won't gradually update on it's own\n\n      if (this.params && !(0, _reactFastCompare[\"default\"])(this.config.radius, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.radius)) {\n        this.params.radius = _utils.random.apply(void 0, _toConsumableArray(this.config.radius));\n      }\n\n      if (!(0, _reactFastCompare[\"default\"])(this.config.images, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.images)) {\n        this.selectImage();\n      }\n    }\n  }, {\n    key: \"updateTargetParams\",\n    value: function updateTargetParams() {\n      this.params.nextSpeed = _utils.random.apply(void 0, _toConsumableArray(this.config.speed));\n      this.params.nextWind = _utils.random.apply(void 0, _toConsumableArray(this.config.wind));\n\n      if (this.image) {\n        this.params.nextRotationSpeed = _utils.random.apply(void 0, _toConsumableArray(this.config.rotationSpeed));\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(canvas) {\n      var framesPassed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var _this$params = this.params,\n          x = _this$params.x,\n          y = _this$params.y,\n          rotation = _this$params.rotation,\n          rotationSpeed = _this$params.rotationSpeed,\n          nextRotationSpeed = _this$params.nextRotationSpeed,\n          wind = _this$params.wind,\n          speed = _this$params.speed,\n          nextWind = _this$params.nextWind,\n          nextSpeed = _this$params.nextSpeed,\n          radius = _this$params.radius; // Update current location, wrapping around if going off the canvas\n\n      this.params.x = (x + wind * framesPassed) % (canvas.offsetWidth + radius * 2);\n      if (this.params.x > canvas.offsetWidth + radius) this.params.x = -radius;\n      this.params.y = (y + speed * framesPassed) % (canvas.offsetHeight + radius * 2);\n      if (this.params.y > canvas.offsetHeight + radius) this.params.y = -radius; // Apply rotation\n\n      if (this.image) {\n        this.params.rotation = (rotation + rotationSpeed) % 360;\n      } // Update the wind, speed and rotation towards the desired values\n\n\n      this.params.speed = (0, _utils.lerp)(speed, nextSpeed, 0.01);\n      this.params.wind = (0, _utils.lerp)(wind, nextWind, 0.01);\n      this.params.rotationSpeed = (0, _utils.lerp)(rotationSpeed, nextRotationSpeed, 0.01);\n\n      if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\n        this.updateTargetParams();\n        this.framesSinceLastUpdate = 0;\n      }\n    }\n  }, {\n    key: \"getImageOffscreenCanvas\",\n    value: function getImageOffscreenCanvas(image, size) {\n      var _sizes$size;\n\n      if (image instanceof HTMLImageElement && image.loading) return image;\n      var sizes = Snowflake.offscreenCanvases.get(image);\n\n      if (!sizes) {\n        sizes = {};\n        Snowflake.offscreenCanvases.set(image, sizes);\n      }\n\n      if (!(size in sizes)) {\n        var _canvas$getContext;\n\n        var canvas = document.createElement('canvas');\n        canvas.width = size;\n        canvas.height = size;\n        (_canvas$getContext = canvas.getContext('2d')) === null || _canvas$getContext === void 0 ? void 0 : _canvas$getContext.drawImage(image, 0, 0, size, size);\n        sizes[size] = canvas;\n      }\n\n      return (_sizes$size = sizes[size]) !== null && _sizes$size !== void 0 ? _sizes$size : image;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      if (this.image) {\n        // ctx.save()\n        // ctx.translate(this.params.x, this.params.y)\n        ctx.setTransform(1, 0, 0, 1, this.params.x, this.params.y);\n        var radius = Math.ceil(this.params.radius);\n        ctx.rotate(this.params.rotation * Math.PI / 180);\n        ctx.drawImage(this.getImageOffscreenCanvas(this.image, radius), -Math.ceil(radius / 2), -Math.ceil(radius / 2), radius, radius); // ctx.restore()\n      } else {\n        ctx.beginPath();\n        ctx.arc(this.params.x, this.params.y, this.params.radius, 0, 2 * Math.PI);\n        ctx.fillStyle = this.config.color;\n        ctx.closePath();\n        ctx.fill();\n      }\n    }\n  }]);\n\n  return Snowflake;\n}();\n\n_defineProperty(Snowflake, \"offscreenCanvases\", new WeakMap());\n\nvar _default = Snowflake;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/Snowflake.ts"],"names":["defaultConfig","color","radius","speed","wind","changeFrequency","rotationSpeed","Snowflake","config","x","canvas","y","rotation","random","nextSpeed","nextWind","nextRotationSpeed","previousConfig","framesPassed","image","sizes","size","document","ctx","Math"],"mappings":"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","sourcesContent":["import isEqual from 'react-fast-compare'\r\nimport { lerp, random, randomElement } from './utils'\r\n\r\nexport interface SnowflakeProps {\r\n  /** The color of the snowflake, can be any valid CSS color. */\r\n  color: string\r\n  /**\r\n   * The minimum and maximum radius of the snowflake, will be\r\n   * randomly selected within this range.\r\n   *\r\n   * The default value is `[0.5, 3.0]`.\r\n   */\r\n  radius: [number, number]\r\n  /**\r\n   * The minimum and maximum speed of the snowflake.\r\n   *\r\n   * The speed determines how quickly the snowflake moves\r\n   * along the y axis (vertical speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[1.0, 3.0]`.\r\n   */\r\n  speed: [number, number]\r\n  /**\r\n   * The minimum and maximum wind of the snowflake.\r\n   *\r\n   * The wind determines how quickly the snowflake moves\r\n   * along the x axis (horizontal speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-0.5, 2.0]`.\r\n   */\r\n  wind: [number, number]\r\n  /**\r\n   * The frequency in frames that the wind and speed values\r\n   * will update.\r\n   *\r\n   * The default value is 200.\r\n   */\r\n  changeFrequency: number\r\n  /**\r\n   * An array of images that will be rendered as the snowflakes instead\r\n   * of the default circle shapes.\r\n   */\r\n  images?: CanvasImageSource[]\r\n  /**\r\n   * The minimum and maximum rotation speed of the snowflake (in degrees of\r\n   * rotation per frame).\r\n   *\r\n   * The rotation speed determines how quickly the snowflake rotates when\r\n   * an image is being rendered.\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-1.0, 1.0]`.\r\n   */\r\n  rotationSpeed: [number, number]\r\n}\r\n\r\nexport type SnowflakeConfig = Partial<SnowflakeProps>\r\n\r\nexport const defaultConfig: SnowflakeProps = {\r\n  color: '#dee4fd',\r\n  radius: [0.5, 3.0],\r\n  speed: [1.0, 3.0],\r\n  wind: [-0.5, 2.0],\r\n  changeFrequency: 200,\r\n  rotationSpeed: [-1.0, 1.0],\r\n}\r\n\r\ninterface SnowflakeParams {\r\n  x: number\r\n  y: number\r\n  radius: number\r\n  rotation: number\r\n  rotationSpeed: number\r\n  speed: number\r\n  wind: number\r\n  nextSpeed: number\r\n  nextWind: number\r\n  nextRotationSpeed: number\r\n}\r\n\r\n/**\r\n * An individual snowflake that will update it's location every call to `update`\r\n * and draw itself to the canvas every call to `draw`.\r\n */\r\nclass Snowflake {\r\n  static offscreenCanvases = new WeakMap<CanvasImageSource, Record<number, HTMLCanvasElement>>()\r\n\r\n  private config!: SnowflakeProps\r\n  private params: SnowflakeParams\r\n  private framesSinceLastUpdate: number\r\n  private image?: CanvasImageSource\r\n\r\n  public constructor(canvas: HTMLCanvasElement, config: SnowflakeConfig = {}) {\r\n    // Set custom config\r\n    this.updateConfig(config)\r\n\r\n    // Setting initial parameters\r\n    const { radius, wind, speed, rotationSpeed } = this.config\r\n\r\n    this.params = {\r\n      x: random(0, canvas.offsetWidth),\r\n      y: random(-canvas.offsetHeight, 0),\r\n      rotation: random(0, 360),\r\n      radius: random(...radius),\r\n      speed: random(...speed),\r\n      wind: random(...wind),\r\n      rotationSpeed: random(...rotationSpeed),\r\n      nextSpeed: random(...wind),\r\n      nextWind: random(...speed),\r\n      nextRotationSpeed: random(...rotationSpeed),\r\n    }\r\n\r\n    this.framesSinceLastUpdate = 0\r\n  }\r\n\r\n  private selectImage() {\r\n    if (this.config.images && this.config.images.length > 0) {\r\n      this.image = randomElement(this.config.images)\r\n    } else {\r\n      this.image = undefined\r\n    }\r\n  }\r\n\r\n  public updateConfig(config: SnowflakeConfig): void {\r\n    const previousConfig = this.config\r\n    this.config = { ...defaultConfig, ...config }\r\n    this.config.changeFrequency = random(this.config.changeFrequency, this.config.changeFrequency * 1.5)\r\n\r\n    // Update the radius if the config has changed, it won't gradually update on it's own\r\n    if (this.params && !isEqual(this.config.radius, previousConfig?.radius)) {\r\n      this.params.radius = random(...this.config.radius)\r\n    }\r\n\r\n    if (!isEqual(this.config.images, previousConfig?.images)) {\r\n      this.selectImage()\r\n    }\r\n  }\r\n\r\n  private updateTargetParams(): void {\r\n    this.params.nextSpeed = random(...this.config.speed)\r\n    this.params.nextWind = random(...this.config.wind)\r\n    if (this.image) {\r\n      this.params.nextRotationSpeed = random(...this.config.rotationSpeed)\r\n    }\r\n  }\r\n\r\n  public update(canvas: HTMLCanvasElement, framesPassed = 1): void {\r\n    const { x, y, rotation, rotationSpeed, nextRotationSpeed, wind, speed, nextWind, nextSpeed, radius } = this.params\r\n\r\n    // Update current location, wrapping around if going off the canvas\r\n    this.params.x = (x + wind * framesPassed) % (canvas.offsetWidth + radius * 2)\r\n    if (this.params.x > canvas.offsetWidth + radius) this.params.x = -radius\r\n    this.params.y = (y + speed * framesPassed) % (canvas.offsetHeight + radius * 2)\r\n    if (this.params.y > canvas.offsetHeight + radius) this.params.y = -radius\r\n\r\n    // Apply rotation\r\n    if (this.image) {\r\n      this.params.rotation = (rotation + rotationSpeed) % 360\r\n    }\r\n\r\n    // Update the wind, speed and rotation towards the desired values\r\n    this.params.speed = lerp(speed, nextSpeed, 0.01)\r\n    this.params.wind = lerp(wind, nextWind, 0.01)\r\n    this.params.rotationSpeed = lerp(rotationSpeed, nextRotationSpeed, 0.01)\r\n\r\n    if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\r\n      this.updateTargetParams()\r\n      this.framesSinceLastUpdate = 0\r\n    }\r\n  }\r\n\r\n  private getImageOffscreenCanvas(image: CanvasImageSource, size: number): CanvasImageSource {\r\n    if (image instanceof HTMLImageElement && image.loading) return image\r\n    let sizes = Snowflake.offscreenCanvases.get(image)\r\n\r\n    if (!sizes) {\r\n      sizes = {}\r\n      Snowflake.offscreenCanvases.set(image, sizes)\r\n    }\r\n\r\n    if (!(size in sizes)) {\r\n      const canvas = document.createElement('canvas')\r\n      canvas.width = size\r\n      canvas.height = size\r\n      canvas.getContext('2d')?.drawImage(image, 0, 0, size, size)\r\n      sizes[size] = canvas\r\n    }\r\n\r\n    return sizes[size] ?? image\r\n  }\r\n\r\n  public draw(ctx: CanvasRenderingContext2D): void {\r\n    if (this.image) {\r\n      // ctx.save()\r\n      // ctx.translate(this.params.x, this.params.y)\r\n      ctx.setTransform(1, 0, 0, 1, this.params.x, this.params.y)\r\n\r\n      const radius = Math.ceil(this.params.radius)\r\n      ctx.rotate((this.params.rotation * Math.PI) / 180)\r\n      ctx.drawImage(\r\n        this.getImageOffscreenCanvas(this.image, radius),\r\n        -Math.ceil(radius / 2),\r\n        -Math.ceil(radius / 2),\r\n        radius,\r\n        radius,\r\n      )\r\n\r\n      // ctx.restore()\r\n    } else {\r\n      ctx.beginPath()\r\n      ctx.arc(this.params.x, this.params.y, this.params.radius, 0, 2 * Math.PI)\r\n      ctx.fillStyle = this.config.color\r\n      ctx.closePath()\r\n      ctx.fill()\r\n    }\r\n  }\r\n}\r\n\r\nexport default Snowflake\r\n"]},"metadata":{},"sourceType":"script"}